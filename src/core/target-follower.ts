import { Graph } from "../data/graph";
/**
 * @file target-follower.ts
 * 
 * @author Brandt
 * @date 2020/10/02
 * @license Zlib
 * 
 * Interface for a target-following object.
 */

import { Deque } from "../util/deque";

/**
 * Interface for an strategy used to follow some target.
 */
export interface TargetFollowingStrategy<U, G extends Graph<U>>
{
    /**
     * @returns the calculated path to the target, or undefined if none has
     *          been found.
     */
    path(): Deque<U> | undefined;

    /**
     * Updates path calculation.
     * 
     * @param map - graph on which to calculate the path.
     */
    update(map: G): void;

    /**
     * Signals failure when trying to follow a path generated by the strategy.
     * Used for recovery when a path becomes invalid after calculation.
     * 
     * @param map - graph on which to calculate the path.
     */
    onFail(map: G): void;

    /**
     * Signals that the follower has finished following a path that was
     * generated by the strategy. This can used to compute partial paths and
     * then complete them later as possible/necessary.
     * 
     * @param map - graph on which to calculate the path.
     * @param v - the actual vertex where the follower stopped.
     */
    onFinish(map: G, v: U): boolean;
}

/**
 * Interface for an object that can follow a target.
 */
export interface TargetFollower<T, U, G extends Graph<U> = Graph<U>>
{
    /**
     * Assigns a target to this follower.
     * 
     * @param target - target object.
     * @param strategy - target following strategy.
     * 
     * @see TargetFollowingStrategy
     */
    follow<H extends G>(
        target: T,
        strategy: new (s: this, t: T) => TargetFollowingStrategy<U, H>
    ): void;
}
